<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mycorrhizal Network</title>
    <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Raleway', sans-serif;
            background: #ffffff;
            color: #333333;
            min-height: 100vh;
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        svg {
            width: 100%;
            height: 100%;
            display: block;
        }

        .edge {
            stroke: rgba(60, 100, 100, 0.25);
            stroke-width: 1;
            fill: none;
            transition: stroke 0.3s, stroke-width 0.3s;
        }

        .edge.highlighted {
            stroke: rgba(40, 80, 80, 0.8);
            stroke-width: 2;
        }

        .edge.dimmed {
            stroke: rgba(60, 100, 100, 0.08);
        }

        .node {
            cursor: pointer;
            transition: opacity 0.3s;
        }

        .node.dimmed {
            opacity: 0.2;
        }

        .node circle {
            stroke-width: 2;
            transition: stroke-width 0.3s, filter 0.3s;
        }

        .node.highlighted circle {
            stroke-width: 3;
            filter: drop-shadow(0 0 8px currentColor);
        }

        .node-label {
            font-size: 10px;
            font-weight: 400;
            fill: #555555;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .node-label.always-visible {
            opacity: 1;
        }

        .node.highlighted .node-label,
        .node:hover .node-label {
            opacity: 1;
        }

        .theme-label {
            font-size: 13px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            pointer-events: none;
            opacity: 0.6;
        }

        #tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.97);
            border: 1px solid rgba(60, 100, 100, 0.3);
            border-radius: 4px;
            padding: 12px 16px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 280px;
            z-index: 100;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
        }

        #tooltip.visible {
            opacity: 1;
        }

        #tooltip .title {
            font-weight: 600;
            margin-bottom: 4px;
            color: #222;
        }

        #tooltip .author {
            font-weight: 300;
            color: #666666;
            margin-bottom: 8px;
        }

        #tooltip .theme {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            padding: 3px 8px;
            border-radius: 2px;
            display: inline-block;
        }

        #tooltip .connections {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(60, 100, 100, 0.2);
            font-size: 12px;
            color: #666666;
        }

        #legend {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 16px;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .legend-item:hover {
            opacity: 1;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        #edge-tooltip {
            position: absolute;
            background: rgba(255, 255, 255, 0.97);
            border: 1px solid rgba(60, 100, 100, 0.3);
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
            color: #555555;
            box-shadow: 0 2px 12px rgba(0,0,0,0.1);
        }

        #edge-tooltip.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="container">
        <svg id="network"></svg>
        <div id="tooltip"></div>
        <div id="edge-tooltip"></div>
        <div id="legend"></div>
    </div>

    <script>
        const themes = {
            growing: { 
                name: 'Growing', 
                color: '#4a9e7d',
                angle: 0
            },
            innovation: { 
                name: 'Innovation', 
                color: '#7a5195',
                angle: 60
            },
            capability: { 
                name: 'Capability', 
                color: '#ef5675',
                angle: 120
            },
            teams: { 
                name: 'Teams', 
                color: '#ffa600',
                angle: 180
            },
            relationality: { 
                name: 'Relationality', 
                color: '#00b4d8',
                angle: 240
            },
            howisee: { 
                name: 'How I See', 
                color: '#90be6d',
                angle: 300
            }
        };

        const nodes = [
            // Growing
            { id: 'fukuoka', label: 'The One Straw Revolution', author: 'Masanobu Fukuoka', theme: 'growing' },
            { id: 'katz', label: 'Fermentation as Metaphor', author: 'Sandor Katz', theme: 'growing' },
            { id: 'baker', label: 'Videos', author: 'Laurie Baker', theme: 'growing' },
            { id: 'miyazaki', label: 'Spirited Away', author: 'Hayao Miyazaki', theme: 'growing' },
            { id: 'asterix', label: 'Asterix Comics', author: 'Goscinny & Uderzo', theme: 'growing' },
            
            // Innovation
            { id: 'mao', label: 'Guerilla Warfare', author: 'Mao Tse Tung', theme: 'innovation' },
            { id: 'escobar', label: 'Designs for the Pluriverse', author: 'Arturo Escobar', theme: 'innovation' },
            { id: 'satrapi', label: 'Persepolis', author: 'Marjane Satrapi', theme: 'innovation' },
            { id: 'tanna', label: 'Tanna', author: 'Butler & Dean', theme: 'innovation' },
            { id: 'yunus', label: 'Grameen Bank', author: 'Muhammad Yunus', theme: 'innovation' },
            
            // Capability
            { id: 'spiller', label: 'Wayfinding Leadership', author: 'Spiller, Barclay-Kerr & Panoho', theme: 'capability' },
            { id: 'yunkaporta', label: 'Sand Talk', author: 'Tyson Yunkaporta', theme: 'capability' },
            { id: 'kimmerer', label: 'Braiding Sweetgrass', author: 'Robin Wall Kimmerer', theme: 'capability' },
            { id: 'tamasese', label: 'The Orator', author: 'Tusi Tamasese', theme: 'capability' },
            { id: 'pirsig', label: 'Zen and the Art of Motorcycle Maintenance', author: 'Robert Pirsig', theme: 'capability' },
            
            // Teams
            { id: 'giuffre', label: 'Collective Creativity', author: 'Katherine Giuffre', theme: 'teams' },
            { id: 'tsing', label: 'The Mushroom at the End of the World', author: 'Anna Lowenhaupt Tsing', theme: 'teams' },
            { id: 'simard', label: 'Finding the Mother Tree', author: 'Suzanne Simard', theme: 'teams' },
            { id: 'darkhorse', label: 'The Dark Horse', author: 'James Napier Robinson', theme: 'teams' },
            { id: 'kerr', label: 'Legacy', author: 'James Kerr', theme: 'teams' },
            
            // Relationality
            { id: 'gaiman', label: 'The Sandman', author: 'Neil Gaiman', theme: 'relationality' },
            { id: 'mollerup', label: 'Wayshowing > Wayfinding', author: 'Per Mollerup', theme: 'relationality' },
            { id: 'fadiman', label: 'The Spirit Catches You and You Fall Down', author: 'Anne Fadiman', theme: 'relationality' },
            { id: 'birddavid', label: '"Animism" Revisited', author: 'Nurit Bird-David', theme: 'relationality' },
            { id: 'tan', label: 'The Arrival', author: 'Shaun Tan', theme: 'relationality' },
            
            // How I See
            { id: 'jacob', label: 'Zorami', author: 'Malsawmi Jacob', theme: 'howisee' },
            { id: 'roy', label: 'The God of Small Things', author: 'Arundhati Roy', theme: 'howisee' },
            { id: 'ong', label: 'Orality and Literacy', author: 'Walter Ong', theme: 'howisee' },
            { id: 'pettitt', label: 'The Gutenberg Parenthesis', author: 'Tom Pettitt', theme: 'howisee' },
            { id: 'scott', label: 'The Art of Not Being Governed', author: 'James C. Scott', theme: 'howisee' }
        ];

        const edges = [
            // Resistance from apparent weakness
            { source: 'mao', target: 'asterix', concept: 'Resistance from apparent weakness' },
            { source: 'mao', target: 'scott', concept: 'Peasant evasion of state power' },
            { source: 'yunus', target: 'darkhorse', concept: 'Unlikely actors, structural disadvantage' },
            
            // Subtraction / non-accumulation
            { source: 'fukuoka', target: 'yunkaporta', concept: 'Knowledge practiced, not stored' },
            { source: 'pirsig', target: 'baker', concept: 'Craft, care, quality of attention' },
            
            // Mycorrhizal / underground networks
            { source: 'tsing', target: 'kimmerer', concept: 'Plant relations, reciprocity' },
            { source: 'simard', target: 'kimmerer', concept: 'Forest communication, mutual aid' },
            
            // Relational ontology / animism
            { source: 'birddavid', target: 'kimmerer', concept: 'More-than-human persons' },
            { source: 'birddavid', target: 'yunkaporta', concept: 'Indigenous relational epistemology' },
            { source: 'birddavid', target: 'escobar', concept: 'Relational ontologies, pluriverse' },
            
            // Navigation / wayfinding
            { source: 'spiller', target: 'mollerup', concept: 'Environmental reading, orientation' },
            { source: 'spiller', target: 'kerr', concept: 'Māori knowledge in teams' },
            
            // Oral / post-literate / visual
            { source: 'ong', target: 'tan', concept: 'Wordless, non-textual meaning' },
            { source: 'ong', target: 'satrapi', concept: 'Graphic form as oral-adjacent' },
            { source: 'satrapi', target: 'gaiman', concept: 'Comics form, image-text integration' },
            { source: 'satrapi', target: 'tan', concept: 'Graphic memoir/narrative' },
            
            // Transformation through struggle/labour
            { source: 'miyazaki', target: 'mao', concept: 'Becoming through protracted effort' },
            { source: 'miyazaki', target: 'darkhorse', concept: 'Unlikely transformation' },
            
            // Cultural collision / incommensurability
            { source: 'fadiman', target: 'scott', concept: 'Hmong as Zomia people' },
            { source: 'fadiman', target: 'jacob', concept: 'Hill peoples, insurgency' },
            
            // Standing / position confers capability
            { source: 'tamasese', target: 'giuffre', concept: 'Position shapes capability' },
            { source: 'tamasese', target: 'roy', concept: 'Caste/standing, who speaks' },
            
            // Narrative / myth as constitutive
            { source: 'gaiman', target: 'tanna', concept: 'Myth holding community' },
            { source: 'gaiman', target: 'tamasese', concept: 'Narrative as action' },
            
            // Decolonising / pluriverse
            { source: 'escobar', target: 'yunkaporta', concept: 'Indigenous systems, other worlds' },
            { source: 'escobar', target: 'scott', concept: 'Illegibility as resistance' },
            { source: 'escobar', target: 'roy', concept: 'Small against totalising systems' },
            
            // Fermentation / decay as generative
            { source: 'katz', target: 'tsing', concept: 'Transformation through decay' },

            
            // Post-literate / secondary orality (within How I See)
            { source: 'pettitt', target: 'ong', concept: 'Secondary orality, post-literate' },
            { source: 'pettitt', target: 'scott', concept: 'Orality in practice' },
            
            // Zomia / hill peoples
            { source: 'jacob', target: 'scott', concept: 'Mizo as Zomia people' },
            
            // Spirit worlds / animist ontology
            { source: 'miyazaki', target: 'birddavid', concept: 'Spirits as persons, animist ontology' },

            
            // Pacific / living tradition
            { source: 'tanna', target: 'tamasese', concept: 'Pacific living traditions under pressure' },
            { source: 'spiller', target: 'tamasese', concept: 'Pacific navigation, standing and oratory' },
            { source: 'darkhorse', target: 'kerr', concept: 'Māori contexts' },
            
            // Craft / quality of attention
            { source: 'pirsig', target: 'fukuoka', concept: 'Quality as attending to what is already there' },
            
            // Stewardship / inheritance

            { source: 'kerr', target: 'tamasese', concept: 'Pacific inheritance' },
            
            // Collaborative survival in precarious conditions
            { source: 'tsing', target: 'yunus', concept: 'Making life in disturbed ground' },
            { source: 'tsing', target: 'fadiman', concept: 'Survival when worlds do not translate' },
            
            // Constraint as generative
            { source: 'baker', target: 'escobar', concept: 'Design with local materials, against universalising' },
            
            // Overlooked / small against systems
            { source: 'yunus', target: 'roy', concept: 'Those invisible to formal systems' },
            { source: 'asterix', target: 'scott', concept: 'Small communities against empire' },
            
            // Pattern / relational structure
            { source: 'yunkaporta', target: 'giuffre', concept: 'Structural position shapes what emerges' },
            
            // Within-theme: Growing
            { source: 'fukuoka', target: 'katz', concept: 'Working with natural processes, not against' },
            { source: 'fukuoka', target: 'baker', concept: 'Subtraction, using what\'s already there' },
            { source: 'katz', target: 'baker', concept: 'Craft knowledge transmitted through practice' },
            { source: 'miyazaki', target: 'fukuoka', concept: 'Spiritual dimension of nature, transformation through tending' },
            { source: 'asterix', target: 'baker', concept: 'Small-scale sufficiency against expansion logic' },
            
            // Within-theme: Innovation
            { source: 'mao', target: 'satrapi', concept: 'Revolution lived from inside' },
            { source: 'escobar', target: 'tanna', concept: 'Local worlds under pressure from universalising systems' },
            { source: 'escobar', target: 'yunus', concept: 'Alternative development, design from margins' },
            { source: 'satrapi', target: 'tanna', concept: 'Personal narrative holding cultural collision' },
            { source: 'yunus', target: 'mao', concept: 'Mobilising the overlooked' },
            
            // Within-theme: Capability
            { source: 'spiller', target: 'yunkaporta', concept: 'Indigenous navigation, reading pattern' },
            { source: 'spiller', target: 'kimmerer', concept: 'Indigenous ecological knowledge' },
            { source: 'yunkaporta', target: 'kimmerer', concept: 'Knowledge as relationship, not extraction' },

            { source: 'yunkaporta', target: 'pirsig', concept: 'Pattern recognition across domains' },
            { source: 'tamasese', target: 'kimmerer', concept: 'Standing in relation to land and ancestors' },
            
            // Within-theme: Teams
            { source: 'giuffre', target: 'tsing', concept: 'Emergence from assemblage, not design' },
            { source: 'giuffre', target: 'simard', concept: 'Network position shapes what flows' },
            { source: 'tsing', target: 'simard', concept: 'Fungal networks, interspecies collaboration' },
            { source: 'simard', target: 'kerr', concept: 'Legacy, what dying feeds forward' },
            { source: 'darkhorse', target: 'giuffre', concept: 'Collective emerges from who\'s actually there' },
            
            // Within-theme: Relationality
            { source: 'gaiman', target: 'tan', concept: 'Visual/mythic storytelling, dream logic' },
            { source: 'gaiman', target: 'birddavid', concept: 'Non-human persons, animist cosmology' },
            { source: 'mollerup', target: 'tan', concept: 'Spatial reading, orientation without text' },
            { source: 'fadiman', target: 'birddavid', concept: 'Incommensurable ontologies meeting' },
            { source: 'tan', target: 'fadiman', concept: 'Navigating worlds that don\'t translate' },
            
            // Within-theme: How I See
            { source: 'jacob', target: 'roy', concept: 'Postcolonial literature, marginal voices' },
            { source: 'roy', target: 'scott', concept: 'Small against systems, what escapes capture' },
            { source: 'ong', target: 'scott', concept: 'Oral cultures and state illegibility' },
            
            // Additional Tsing connections
            { source: 'tsing', target: 'escobar', concept: 'Pluriverse, living in ruins of capitalism' },
            { source: 'tsing', target: 'scott', concept: 'Matsutake pickers as populations evading capture' },
            { source: 'tsing', target: 'birddavid', concept: 'More-than-human relations, relational ontology' },
            
            // Additional Fukuoka connections
            { source: 'fukuoka', target: 'kimmerer', concept: 'Learning from plants, reciprocity with nature' },
            { source: 'fukuoka', target: 'simard', concept: 'Farm/forest as interconnected system, not individuals to manage' },
            { source: 'fukuoka', target: 'tsing', concept: 'What emerges without human control, limits of management' },
            { source: 'fukuoka', target: 'scott', concept: 'Farming illegible to state, resists scientific agriculture' },
            { source: 'fukuoka', target: 'escobar', concept: 'Anti-development, critique of modernisation' },
            
            // Additional Spiller connections
            { source: 'spiller', target: 'giuffre', concept: 'Relational leadership, position in network shapes capability' },
            { source: 'spiller', target: 'simard', concept: 'Reading distributed signals, hub roles in networks' },
            { source: 'spiller', target: 'darkhorse', concept: 'Māori leadership in uncertain conditions' },
            { source: 'spiller', target: 'escobar', concept: 'Pluriversal navigation, non-Western knowledge systems' },
            { source: 'spiller', target: 'gaiman', concept: 'Narrative as navigation, myth holding direction' },
            { source: 'spiller', target: 'scott', concept: 'Navigation as illegibility, reading what states cannot see' },
            
            // Additional Gaiman connections
            { source: 'gaiman', target: 'jacob', concept: 'Narrative holding trauma, stories that reconstitute community' },
            { source: 'gaiman', target: 'roy', concept: 'Literary voice carrying what academic prose cannot' },
            { source: 'gaiman', target: 'miyazaki', concept: 'Dream worlds, spirits, transformation through story' },
            { source: 'gaiman', target: 'kerr', concept: 'Myth and legacy, stories that bind across time' },
            { source: 'gaiman', target: 'yunkaporta', concept: 'Dreaming, story as knowledge system' }
        ];

        // Count connections for node sizing
        const connectionCount = {};
        nodes.forEach(n => connectionCount[n.id] = 0);
        edges.forEach(e => {
            connectionCount[e.source]++;
            connectionCount[e.target]++;
        });

        // Setup SVG
        const svg = d3.select('#network');
        const container = document.getElementById('container');
        const width = container.clientWidth;
        const height = container.clientHeight;
        const centerX = width / 2;
        const centerY = height / 2;
        const orbitRadius = Math.min(width, height) * 0.32;

        svg.attr('viewBox', `0 0 ${width} ${height}`);

        // Create gradient for background
        const defs = svg.append('defs');
        
        const radialGradient = defs.append('radialGradient')
            .attr('id', 'bgGradient')
            .attr('cx', '50%')
            .attr('cy', '50%')
            .attr('r', '50%');
        
        radialGradient.append('stop')
            .attr('offset', '0%')
            .attr('stop-color', '#ffffff');
        
        radialGradient.append('stop')
            .attr('offset', '100%')
            .attr('stop-color', '#f5f8f8');

        svg.append('rect')
            .attr('width', width)
            .attr('height', height)
            .attr('fill', 'url(#bgGradient)');

        // Calculate theme anchor positions
        const themeAnchors = {};
        Object.entries(themes).forEach(([key, theme]) => {
            const angle = (theme.angle - 90) * Math.PI / 180;
            themeAnchors[key] = {
                x: centerX + orbitRadius * Math.cos(angle),
                y: centerY + orbitRadius * Math.sin(angle)
            };
        });

        // Initialize node positions near their theme anchors
        nodes.forEach(node => {
            const anchor = themeAnchors[node.theme];
            const scatter = 50;
            node.x = anchor.x + (Math.random() - 0.5) * scatter;
            node.y = anchor.y + (Math.random() - 0.5) * scatter;
        });

        // Create simulation
        const simulation = d3.forceSimulation(nodes)
            .force('charge', d3.forceManyBody().strength(-100))
            .force('link', d3.forceLink(edges).id(d => d.id).distance(150).strength(0.3))
            .force('themeGravity', alpha => {
                nodes.forEach(node => {
                    const anchor = themeAnchors[node.theme];
                    const strength = 0.08;
                    node.vx += (anchor.x - node.x) * strength * alpha;
                    node.vy += (anchor.y - node.y) * strength * alpha;
                });
            })
            .force('collision', d3.forceCollide().radius(d => getNodeRadius(d) + 5))
            .force('center', d3.forceCenter(centerX, centerY).strength(0.02));

        // Draw edges
        const edgeGroup = svg.append('g').attr('class', 'edges');
        const edgeElements = edgeGroup.selectAll('.edge')
            .data(edges)
            .enter()
            .append('line')
            .attr('class', 'edge')
            .on('mouseenter', (event, d) => showEdgeTooltip(event, d))
            .on('mouseleave', hideEdgeTooltip);

        // Draw theme labels
        const labelGroup = svg.append('g').attr('class', 'theme-labels');
        Object.entries(themes).forEach(([key, theme]) => {
            const anchor = themeAnchors[key];
            const labelOffset = 80;
            const angle = (theme.angle - 90) * Math.PI / 180;
            const labelX = centerX + (orbitRadius + labelOffset) * Math.cos(angle);
            const labelY = centerY + (orbitRadius + labelOffset) * Math.sin(angle);
            
            labelGroup.append('text')
                .attr('class', 'theme-label')
                .attr('x', labelX)
                .attr('y', labelY)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr('fill', theme.color)
                .text(theme.name);
        });

        // Draw nodes
        const nodeGroup = svg.append('g').attr('class', 'nodes');
        const nodeElements = nodeGroup.selectAll('.node')
            .data(nodes)
            .enter()
            .append('g')
            .attr('class', 'node')
            .on('mouseenter', (event, d) => highlightNode(d))
            .on('mouseleave', resetHighlight)
            .call(d3.drag()
                .on('start', dragStarted)
                .on('drag', dragged)
                .on('end', dragEnded));

        nodeElements.append('circle')
            .attr('r', d => getNodeRadius(d))
            .attr('fill', d => themes[d.theme].color)
            .attr('stroke', d => d3.color(themes[d.theme].color).darker(0.3))
            .style('fill-opacity', 0.85);

        nodeElements.append('text')
            .attr('class', d => connectionCount[d.id] >= 8 ? 'node-label always-visible' : 'node-label')
            .attr('dy', d => getNodeRadius(d) + 14)
            .attr('text-anchor', 'middle')
            .text(d => connectionCount[d.id] >= 8 ? d.label : d.author.split(',')[0].split(' ').pop());

        function getNodeRadius(node) {
            const count = connectionCount[node.id];
            const minRadius = 6;
            const maxRadius = 18;
            return minRadius + (count / 4) * (maxRadius - minRadius);
        }

        // Tooltip functions
        const tooltip = document.getElementById('tooltip');
        const edgeTooltip = document.getElementById('edge-tooltip');

        function highlightNode(node) {
            const connectedIds = new Set([node.id]);
            const connectedEdges = [];
            
            edges.forEach(e => {
                const sourceId = typeof e.source === 'object' ? e.source.id : e.source;
                const targetId = typeof e.target === 'object' ? e.target.id : e.target;
                if (sourceId === node.id) {
                    connectedIds.add(targetId);
                    connectedEdges.push(e);
                } else if (targetId === node.id) {
                    connectedIds.add(sourceId);
                    connectedEdges.push(e);
                }
            });

            nodeElements.classed('highlighted', d => d.id === node.id)
                .classed('dimmed', d => !connectedIds.has(d.id));
            
            edgeElements.classed('highlighted', e => {
                const sourceId = typeof e.source === 'object' ? e.source.id : e.source;
                const targetId = typeof e.target === 'object' ? e.target.id : e.target;
                return sourceId === node.id || targetId === node.id;
            }).classed('dimmed', e => {
                const sourceId = typeof e.source === 'object' ? e.source.id : e.source;
                const targetId = typeof e.target === 'object' ? e.target.id : e.target;
                return sourceId !== node.id && targetId !== node.id;
            });

            // Show tooltip
            const theme = themes[node.theme];
            const connections = connectedEdges.map(e => {
                const sourceId = typeof e.source === 'object' ? e.source.id : e.source;
                const otherId = sourceId === node.id ? 
                    (typeof e.target === 'object' ? e.target.id : e.target) : sourceId;
                const otherNode = nodes.find(n => n.id === otherId);
                return `${otherNode.author.split(',')[0].split(' ').pop()}: ${e.concept}`;
            });

            tooltip.innerHTML = `
                <div class="title">${node.label}</div>
                <div class="author">${node.author}</div>
                <div class="theme" style="background: ${theme.color}33; color: ${theme.color}">${theme.name}</div>
                ${connections.length > 0 ? `<div class="connections"><strong>Connections:</strong><br>${connections.join('<br>')}</div>` : ''}
            `;
            tooltip.classList.add('visible');
        }

        function resetHighlight() {
            nodeElements.classed('highlighted', false).classed('dimmed', false);
            edgeElements.classed('highlighted', false).classed('dimmed', false);
            tooltip.classList.remove('visible');
        }

        function showEdgeTooltip(event, edge) {
            edgeTooltip.textContent = edge.concept;
            edgeTooltip.style.left = event.pageX + 10 + 'px';
            edgeTooltip.style.top = event.pageY - 20 + 'px';
            edgeTooltip.classList.add('visible');
        }

        function hideEdgeTooltip() {
            edgeTooltip.classList.remove('visible');
        }

        // Drag functions
        function dragStarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragEnded(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // Update positions on tick
        simulation.on('tick', () => {
            edgeElements
                .attr('x1', d => d.source.x)
                .attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x)
                .attr('y2', d => d.target.y);

            nodeElements.attr('transform', d => `translate(${d.x},${d.y})`);
        });

        // Position tooltip near cursor
        document.addEventListener('mousemove', e => {
            if (tooltip.classList.contains('visible')) {
                const x = Math.min(e.pageX + 15, width - tooltip.offsetWidth - 20);
                const y = Math.min(e.pageY + 15, height - tooltip.offsetHeight - 20);
                tooltip.style.left = x + 'px';
                tooltip.style.top = y + 'px';
            }
        });

        // Build legend
        const legend = document.getElementById('legend');
        Object.entries(themes).forEach(([key, theme]) => {
            const item = document.createElement('div');
            item.className = 'legend-item';
            item.innerHTML = `<div class="legend-dot" style="background: ${theme.color}"></div>${theme.name}`;
            item.addEventListener('click', () => {
                const themeNodes = nodes.filter(n => n.theme === key);
                if (themeNodes.length > 0) {
                    highlightNode(themeNodes[0]);
                }
            });
            legend.appendChild(item);
        });

        // Handle resize
        window.addEventListener('resize', () => {
            location.reload();
        });
    </script>
</body>
</html>
